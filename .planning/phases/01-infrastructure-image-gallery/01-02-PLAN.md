---
phase: 01-infrastructure-image-gallery
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/config/config.go
  - internal/services/media_service.go
autonomous: true
requirements:
  - INFRA-01
  - INFRA-04
must_haves:
  truths:
    - "MediaService exists with methods for image upload orchestration"
    - "Config has upload limit settings for media"
    - "S3 delete operation is available for cleanup"
  artifacts:
    - path: "internal/services/media_service.go"
      provides: "Media orchestration service"
      min_lines: 50
      contains: "type MediaService struct"
    - path: "internal/config/config.go"
      provides: "Upload limit configuration"
      contains: "UploadMaxImageSize"
  key_links:
    - from: "internal/services/media_service.go"
      to: "internal/services/s3_service.go"
      via: "dependency injection"
      pattern: "s3Service.*S3Service"
---

<objective>
Create MediaService for image upload orchestration and add upload limit configuration.

Purpose: Establish the service layer that orchestrates image operations including upload coordination, S3 interaction, and database record management. Add configuration for upload limits to prevent abuse.

Output: New MediaService in internal/services/media_service.go, updated config with media settings
</objective>

<execution_context>
@/home/munnotubbel/.claude/get-shit-done/workflows/execute-plan.md
@/home/munnotubbel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/munnotubbel/github/synesthesie-backend/.planning/PROJECT.md
@/home/munnotubbel/github/synesthesie-backend/.planning/ROADMAP.md
@/home/munnotubbel/github/synesthesie-backend/.planning/REQUIREMENTS.md
@/home/munnotubbel/github/synesthesie-backend/internal/config/config.go
@/home/munnotubbel/github/synesthesie-backend/internal/services/s3_service.go
@/home/munnotubbel/github/synesthesie-backend/internal/services/asset_service.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add media configuration settings</name>
  <files>internal/config/config.go</files>
  <action>
Add media-related configuration fields to the Config struct in internal/config/config.go:

1. Add to Config struct (after existing media fields, around line 97-99):
```go
// Media upload limits
UploadMaxImageSize     int64  // Max image size in bytes (default: 25MB)
UploadMaxConcurrent    int    // Max concurrent uploads per admin (default: 3)
PresignedURLTTLMinutes int    // TTL for presigned URLs in minutes (default: 15)
```

2. Add defaults to New() function (after MediaCacheAudio line, around line 227):
```go
// Media upload limits
UploadMaxImageSize:     getEnvAsInt64("UPLOAD_MAX_IMAGE_SIZE", 25*1024*1024), // 25MB
UploadMaxConcurrent:    getEnvAsInt("UPLOAD_MAX_CONCURRENT", 3),
PresignedURLTTLMinutes: getEnvAsInt("PRESIGNED_URL_TTL_MINUTES", 15),
```

3. Add helper function getEnvAsInt64 if not present:
```go
func getEnvAsInt64(key string, defaultValue int64) int64 {
    valueStr := getEnv(key, "")
    if value, err := strconv.ParseInt(valueStr, 10, 64); err == nil {
        return value
    }
    return defaultValue
}
```

These settings support INFRA-01 (MEDIA_ASSETS_BUCKET already exists) and INFRA-04 (Config extension for media settings).
</action>
  <verify>
go build ./... 2>&1 | head -20
</verify>
  <done>
Config struct has UploadMaxImageSize, UploadMaxConcurrent, PresignedURLTTLMinutes fields with defaults
</done>
</task>

<task type="auto">
  <name>Task 2: Create MediaService for orchestration</name>
  <files>internal/services/media_service.go</files>
  <action>
Create a new file internal/services/media_service.go:

```go
package services

import (
    "bytes"
    "context"
    "fmt"
    "net/http"
    "path/filepath"
    "strings"
    "time"

    "github.com/google/uuid"
    "github.com/synesthesie/backend/internal/config"
    "github.com/synesthesie/backend/internal/models"
    "gorm.io/gorm"
)

type MediaService struct {
    db        *gorm.DB
    cfg       *config.Config
    s3Service *S3Service
}

func NewMediaService(db *gorm.DB, cfg *config.Config, s3Service *S3Service) *MediaService {
    return &MediaService{
        db:        db,
        cfg:       cfg,
        s3Service: s3Service,
    }
}

// UploadImage uploads an image to S3 and creates DB records
// Returns the created Image and Asset, or error
func (s *MediaService) UploadImage(ctx context.Context, filename string, data []byte, title, description string) (*models.Image, error) {
    // Validate MIME type using content detection (IMG-ADM-06)
    mimeType := http.DetectContentType(data)
    if !strings.HasPrefix(mimeType, "image/") {
        return nil, fmt.Errorf("invalid content type: expected image, got %s", mimeType)
    }

    // Validate file extension
    ext := strings.ToLower(filepath.Ext(filename))
    allowedExts := map[string]bool{".jpg": true, ".jpeg": true, ".png": true, ".webp": true}
    if !allowedExts[ext] {
        return nil, fmt.Errorf("unsupported image extension: %s", ext)
    }

    // Validate size
    if int64(len(data)) > s.cfg.UploadMaxImageSize {
        return nil, fmt.Errorf("image too large: %d bytes (max: %d)", len(data), s.cfg.UploadMaxImageSize)
    }

    // Generate S3 key
    key := fmt.Sprintf("images/%s%s", uuid.New().String(), ext)

    // Upload to S3 (mediaClient -> MediaImagesBucket)
    if err := s.s3Service.UploadMedia(ctx, s.cfg.MediaImagesBucket, key, bytes.NewReader(data), mimeType); err != nil {
        return nil, fmt.Errorf("failed to upload to S3: %w", err)
    }

    // Create Asset record
    asset := &models.Asset{
        Key:        key,
        Filename:   filename,
        MimeType:   mimeType,
        SizeBytes:  int64(len(data)),
        Visibility: models.AssetVisibilityPrivate, // Always private - images use Image.Visibility
    }
    if err := s.db.Create(asset).Error; err != nil {
        // Attempt S3 cleanup on DB failure (SEC-04)
        _ = s.DeleteS3Object(ctx, key)
        return nil, fmt.Errorf("failed to create asset record: %w", err)
    }

    // Create Image record
    image := &models.Image{
        AssetID:     asset.ID,
        Title:       title,
        Description: description,
        Visibility:  "private", // Default to private
    }
    if err := s.db.Create(image).Error; err != nil {
        // Cleanup: delete asset and S3 object
        s.db.Delete(asset)
        _ = s.DeleteS3Object(ctx, key)
        return nil, fmt.Errorf("failed to create image record: %w", err)
    }

    // Load asset relation
    image.Asset = asset

    return image, nil
}

// DeleteImage deletes an image (S3 + DB) - IMG-ADM-03
// Delete S3 first to avoid orphaned objects (SEC-04)
func (s *MediaService) DeleteImage(ctx context.Context, imageID uuid.UUID) error {
    var image models.Image
    if err := s.db.Preload("Asset").First(&image, "id = ?", imageID).Error; err != nil {
        return fmt.Errorf("image not found: %w", err)
    }

    // Delete from S3 FIRST (SEC-04: avoid orphaned S3 objects)
    if err := s.DeleteS3Object(ctx, image.Asset.Key); err != nil {
        // Log but continue - S3 might already be gone
    }

    // Delete DB records (Image first, then Asset)
    if err := s.db.Delete(&image).Error; err != nil {
        return fmt.Errorf("failed to delete image record: %w", err)
    }
    if err := s.db.Delete(&image.Asset).Error; err != nil {
        return fmt.Errorf("failed to delete asset record: %w", err)
    }

    return nil
}

// DeleteS3Object deletes an object from the media images bucket
func (s *MediaService) DeleteS3Object(ctx context.Context, key string) error {
    // S3Service needs a DeleteMedia method - we'll add it in a helper
    // For now, this is a placeholder that will be implemented
    return fmt.Errorf("DeleteS3Object not yet implemented - requires S3Service extension")
}

// GetPresignedImageURL generates a presigned URL for an image (SEC-01)
func (s *MediaService) GetPresignedImageURL(ctx context.Context, key string) (string, error) {
    ttl := time.Duration(s.cfg.PresignedURLTTLMinutes) * time.Minute
    return s.s3Service.PresignMediaGet(ctx, s.cfg.MediaImagesBucket, key, ttl)
}

// UpdateImageVisibility changes the visibility of an image (IMG-ADM-04)
func (s *MediaService) UpdateImageVisibility(imageID uuid.UUID, visibility string) error {
    if visibility != "private" && visibility != "public" {
        return fmt.Errorf("invalid visibility: must be 'private' or 'public'")
    }
    return s.db.Model(&models.Image{}).Where("id = ?", imageID).Update("visibility", visibility).Error
}

// UpdateImageMetadata updates title and description (IMG-ADM-05)
func (s *MediaService) UpdateImageMetadata(imageID uuid.UUID, title, description string) error {
    updates := map[string]interface{}{}
    if title != "" {
        updates["title"] = title
    }
    if description != "" {
        updates["description"] = description
    }
    if len(updates) == 0 {
        return nil
    }
    return s.db.Model(&models.Image{}).Where("id = ?", imageID).Updates(updates).Error
}

// GetPublicImages returns all public images for user viewing (IMG-USR-01)
func (s *MediaService) GetPublicImages(limit, offset int) ([]models.Image, int64, error) {
    var images []models.Image
    var total int64

    query := s.db.Model(&models.Image{}).Where("visibility = ?", "public")
    if err := query.Count(&total).Error; err != nil {
        return nil, 0, err
    }

    if err := query.Preload("Asset").Order("created_at DESC").Limit(limit).Offset(offset).Find(&images).Error; err != nil {
        return nil, 0, err
    }

    return images, total, nil
}

// GetImageByID returns a single image by ID
func (s *MediaService) GetImageByID(imageID uuid.UUID) (*models.Image, error) {
    var image models.Image
    if err := s.db.Preload("Asset").First(&image, "id = ?", imageID).Error; err != nil {
        return nil, err
    }
    return &image, nil
}

// GetAllImages returns all images for admin (with pagination)
func (s *MediaService) GetAllImages(limit, offset int) ([]models.Image, int64, error) {
    var images []models.Image
    var total int64

    if err := s.db.Model(&models.Image{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    if err := s.db.Preload("Asset").Order("created_at DESC").Limit(limit).Offset(offset).Find(&images).Error; err != nil {
        return nil, 0, err
    }

    return images, total, nil
}
```

Key patterns followed:
- Constructor with dependency injection (like existing services)
- GORM for database operations
- Context for cancellation
- Error wrapping with fmt.Errorf and %w
</action>
  <verify>
go build ./... 2>&1 | head -30
</verify>
  <done>
MediaService exists with UploadImage, DeleteImage, GetPresignedImageURL, UpdateImageVisibility, UpdateImageMetadata, GetPublicImages, GetImageByID, GetAllImages methods
</done>
</task>

<task type="auto">
  <name>Task 3: Add DeleteMedia method to S3Service</name>
  <files>internal/services/s3_service.go</files>
  <action>
Add a DeleteMedia method to S3Service in internal/services/s3_service.go:

Add after the ListMediaKeys function (around line 167):

```go
// DeleteMedia deletes an object from the media bucket
func (s *MediaService) DeleteMedia(ctx context.Context, bucket, key string) error {
    _, err := s.mediaClient.DeleteObject(ctx, &s3.DeleteObjectInput{
        Bucket: &bucket,
        Key:    &key,
    })
    return err
}
```

Then update MediaService.DeleteS3Object to call it:
```go
// DeleteS3Object deletes an object from the media images bucket
func (s *MediaService) DeleteS3Object(ctx context.Context, key string) error {
    return s.s3Service.DeleteMedia(ctx, s.cfg.MediaImagesBucket, key)
}
```
</action>
  <verify>
go build ./... 2>&1 | head -20
</verify>
  <done>
S3Service has DeleteMedia method, MediaService.DeleteS3Object works correctly
</done>
</task>

</tasks>

<verification>
1. Run `go build ./...` - must succeed
2. Verify Config has UploadMaxImageSize, UploadMaxConcurrent, PresignedURLTTLMinutes
3. Verify MediaService has all required methods
4. Verify S3Service has DeleteMedia method
5. Verify MIME type detection uses http.DetectContentType
</verification>

<success_criteria>
- Config extended with upload limit settings (INFRA-04)
- MediaService created with orchestration methods
- S3Service extended with DeleteMedia
- MIME type validation using content detection (IMG-ADM-06)
- Presigned URL TTL configurable (SEC-01)
- Delete order: S3 first, then DB (SEC-04)
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-image-gallery/01-02-SUMMARY.md`
</output>
