---
phase: 01-infrastructure-image-gallery
plan: 03
type: execute
wave: 2
depends_on:
  - 01-01
  - 01-02
files_modified:
  - internal/handlers/media_handler.go
  - cmd/api/main.go
autonomous: true
requirements:
  - IMG-ADM-01
  - IMG-ADM-02
  - IMG-ADM-06
must_haves:
  truths:
    - "Admin can upload single image via POST /admin/images"
    - "Admin can upload multiple images via POST /admin/images/batch"
    - "MIME type is validated from content, not extension"
    - "Uploads are stored in private S3 bucket"
  artifacts:
    - path: "internal/handlers/media_handler.go"
      provides: "Admin image upload handlers"
      exports: ["UploadImage", "UploadImages", "NewMediaHandler"]
      contains: "DetectContentType"
    - path: "cmd/api/main.go"
      provides: "Route registration"
      contains: "/admin/images"
  key_links:
    - from: "internal/handlers/media_handler.go"
      to: "internal/services/media_service.go"
      via: "dependency injection"
      pattern: "mediaService.*MediaService"
---

<objective>
Create admin endpoints for single and multi-image upload with MIME type validation.

Purpose: Enable admins to upload images through REST API endpoints. Single upload for individual images, batch upload for multiple images. MIME type is validated from actual content to prevent spoofing.

Output: New MediaHandler in internal/handlers/media_handler.go, routes registered in main.go
</objective>

<execution_context>
@/home/munnotubbel/.claude/get-shit-done/workflows/execute-plan.md
@/home/munnotubbel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/munnotubbel/github/synesthesie-backend/.planning/PROJECT.md
@/home/munnotubbel/github/synesthesie-backend/.planning/ROADMAP.md
@/home/munnotubbel/github/synesthesie-backend/.planning/REQUIREMENTS.md
@/home/munnotubbel/github/synesthesie-backend/internal/handlers/admin_handler.go
@/home/munnotubbel/github/synesthesie-backend/cmd/api/main.go
@/home/munnotubbel/github/synesthesie-backend/internal/middleware/auth.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MediaHandler for admin image upload</name>
  <files>internal/handlers/media_handler.go</files>
  <action>
Create a new file internal/handlers/media_handler.go:

```go
package handlers

import (
    "io"
    "mime/multipart"
    "net/http"
    "strconv"
    "strings"

    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
    "github.com/synesthesie/backend/internal/services"
)

type MediaHandler struct {
    mediaService *services.MediaService
}

func NewMediaHandler(mediaService *services.MediaService) *MediaHandler {
    return &MediaHandler{
        mediaService: mediaService,
    }
}

// UploadImage handles single image upload (IMG-ADM-01)
// POST /admin/images
// Multipart form: file (required), title (optional), description (optional)
func (h *MediaHandler) UploadImage(c *gin.Context) {
    // Get file from form
    file, header, err := c.Request.FormFile("file")
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "file is required"})
        return
    }
    defer file.Close()

    // Read file content for MIME detection and upload
    data, err := io.ReadAll(file)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "failed to read file"})
        return
    }

    // Get optional metadata
    title := c.PostForm("title")
    description := c.PostForm("description")

    // Upload via MediaService (handles MIME validation internally)
    image, err := h.mediaService.UploadImage(c.Request.Context(), header.Filename, data, title, description)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusCreated, gin.H{
        "id":          image.ID,
        "asset_id":    image.AssetID,
        "title":       image.Title,
        "description": image.Description,
        "visibility":  image.Visibility,
        "filename":    image.Asset.Filename,
        "mime_type":   image.Asset.MimeType,
        "size_bytes":  image.Asset.SizeBytes,
        "created_at":  image.CreatedAt,
    })
}

// UploadImages handles multiple image upload (IMG-ADM-02)
// POST /admin/images/batch
// Multipart form: files[] (multiple files), default_title (optional), default_description (optional)
func (h *MediaHandler) UploadImages(c *gin.Context) {
    // Parse multipart form with larger memory limit for multiple files
    maxMemory := int64(50 * 1024 * 1024) // 50MB total
    if err := c.Request.ParseMultipartForm(maxMemory); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "failed to parse multipart form"})
        return
    }

    form := c.Request.MultipartForm
    files, ok := form.File["files[]"]
    if !ok || len(files) == 0 {
        c.JSON(http.StatusBadRequest, gin.H{"error": "files[] is required"})
        return
    }

    // Limit concurrent uploads to prevent memory exhaustion
    maxConcurrent := 3 // matches config default
    if len(files) > 10 {
        c.JSON(http.StatusBadRequest, gin.H{"error": "maximum 10 files per batch"})
        return
    }

    // Get optional default metadata
    defaultTitle := c.PostForm("default_title")
    defaultDescription := c.PostForm("default_description")

    // Process uploads with concurrency limit
    type uploadResult struct {
        ID     uuid.UUID `json:"id"`
        Status string    `json:"status"`
        Error  string    `json:"error,omitempty"`
    }
    results := make([]uploadResult, len(files))

    // Simple semaphore for concurrency limiting
    sem := make(chan struct{}, maxConcurrent)
    done := make(chan int, len(files))

    for i, fileHeader := range files {
        go func(idx int, fh *multipart.FileHeader) {
            sem <- struct{}{} // acquire
            defer func() { <-sem; done <- idx }()

            file, err := fh.Open()
            if err != nil {
                results[idx] = uploadResult{Status: "error", Error: "failed to open file"}
                return
            }
            defer file.Close()

            data, err := io.ReadAll(file)
            if err != nil {
                results[idx] = uploadResult{Status: "error", Error: "failed to read file"}
                return
            }

            image, err := h.mediaService.UploadImage(c.Request.Context(), fh.Filename, data, defaultTitle, defaultDescription)
            if err != nil {
                results[idx] = uploadResult{Status: "error", Error: err.Error()}
                return
            }

            results[idx] = uploadResult{ID: image.ID, Status: "success"}
        }(i, fileHeader)
    }

    // Wait for all goroutines
    for range files {
        <-done
    }

    // Count successes and failures
    success := 0
    failed := 0
    for _, r := range results {
        if r.Status == "success" {
            success++
        } else {
            failed++
        }
    }

    c.JSON(http.StatusCreated, gin.H{
        "message": "batch upload complete",
        "total":   len(files),
        "success": success,
        "failed":  failed,
        "results": results,
    })
}

// GetAllImages lists all images for admin
// GET /admin/images?page=1&limit=20
func (h *MediaHandler) GetAllImages(c *gin.Context) {
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
    if limit > 100 {
        limit = 100
    }
    offset := (page - 1) * limit

    images, total, err := h.mediaService.GetAllImages(limit, offset)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to retrieve images"})
        return
    }

    // Build response without presigned URLs (admin sees metadata only)
    imageList := make([]gin.H, len(images))
    for i, img := range images {
        imageList[i] = gin.H{
            "id":          img.ID,
            "asset_id":    img.AssetID,
            "title":       img.Title,
            "description": img.Description,
            "visibility":  img.Visibility,
            "filename":    img.Asset.Filename,
            "mime_type":   img.Asset.MimeType,
            "size_bytes":  img.Asset.SizeBytes,
            "created_at":  img.CreatedAt,
            "updated_at":  img.UpdatedAt,
        }
    }

    c.JSON(http.StatusOK, gin.H{
        "images": imageList,
        "pagination": gin.H{
            "page":  page,
            "limit": limit,
            "total": total,
        },
    })
}

// GetImageDetails gets single image details for admin
// GET /admin/images/:id
func (h *MediaHandler) GetImageDetails(c *gin.Context) {
    imageIDStr := c.Param("id")
    imageID, err := uuid.Parse(imageIDStr)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid image ID"})
        return
    }

    image, err := h.mediaService.GetImageByID(imageID)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "image not found"})
        return
    }

    // Generate presigned URL for admin preview
    presignedURL, err := h.mediaService.GetPresignedImageURL(c.Request.Context(), image.Asset.Key)
    if err != nil {
        presignedURL = "" // Continue without URL if presign fails
    }

    c.JSON(http.StatusOK, gin.H{
        "id":            image.ID,
        "asset_id":      image.AssetID,
        "title":         image.Title,
        "description":   image.Description,
        "visibility":    image.Visibility,
        "filename":      image.Asset.Filename,
        "mime_type":     image.Asset.MimeType,
        "size_bytes":    image.Asset.SizeBytes,
        "presigned_url": presignedURL,
        "created_at":    image.CreatedAt,
        "updated_at":    image.UpdatedAt,
    })
}
```

Key patterns:
- Follows existing handler patterns (AdminHandler structure)
- gin.H for JSON responses
- Multipart form parsing like UploadAsset in AdminHandler
- Concurrency limiting for batch uploads (prevent memory exhaustion)
- UUID parsing with uuid.Parse
</action>
  <verify>
go build ./... 2>&1 | head -30
</verify>
  <done>
MediaHandler exists with UploadImage, UploadImages, GetAllImages, GetImageDetails methods
</done>
</task>

<task type="auto">
  <name>Task 2: Wire MediaHandler in main.go</name>
  <files>cmd/api/main.go</files>
  <action>
Update cmd/api/main.go to initialize MediaService and MediaHandler, then register routes:

1. After creating s3Service (around line 64), create MediaService:
```go
mediaService := services.NewMediaService(db, cfg, s3Service)
```

2. After creating other handlers (around line 191), create MediaHandler:
```go
mediaHandler := handlers.NewMediaHandler(mediaService)
```

3. In the admin routes group (after backup routes, around line 321), add image routes:
```go
// Image gallery management
admin.POST("/images", mediaHandler.UploadImage)
admin.POST("/images/batch", mediaHandler.UploadImages)
admin.GET("/images", mediaHandler.GetAllImages)
admin.GET("/images/:id", mediaHandler.GetImageDetails)
```

The routes will be extended in Plan 04 with delete, visibility, and metadata endpoints.
</action>
  <verify>
grep -n "mediaHandler" cmd/api/main.go && go build ./...
</verify>
  <done>
main.go creates MediaService, MediaHandler, and registers /admin/images routes
</done>
</task>

</tasks>

<verification>
1. Run `go build ./...` - must succeed
2. Verify MediaHandler has UploadImage, UploadImages, GetAllImages, GetImageDetails
3. Verify main.go creates MediaService and MediaHandler
4. Verify routes registered: POST /admin/images, POST /admin/images/batch, GET /admin/images, GET /admin/images/:id
5. Verify MIME detection uses content (not just extension)
</verification>

<success_criteria>
- Single image upload endpoint works (IMG-ADM-01)
- Multiple image upload endpoint with concurrency limit (IMG-ADM-02)
- MIME type validated from content using http.DetectContentType (IMG-ADM-06)
- Admin routes properly registered with auth middleware
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-image-gallery/01-03-SUMMARY.md`
</output>
