---
phase: 01-infrastructure-image-gallery
plan: 06
type: execute
wave: 4
depends_on:
  - 01-03
  - 01-04
  - 01-05
files_modified:
  - internal/middleware/upload_rate_limit.go
  - cmd/api/main.go
  - internal/config/config.go
autonomous: true
requirements:
  - SEC-01
  - SEC-02
  - SEC-03
  - SEC-04
must_haves:
  truths:
    - "Upload rate limiting prevents admin abuse"
    - "Presigned URLs expire after 15 minutes"
    - "S3 bucket has no public access"
    - "Image deletion removes S3 object before DB record"
  artifacts:
    - path: "internal/middleware/upload_rate_limit.go"
      provides: "Upload rate limiting middleware"
      contains: "UploadRateLimit"
    - path: "cmd/api/main.go"
      provides: "Middleware integration"
      contains: "UploadRateLimit"
  key_links:
    - from: "internal/middleware/upload_rate_limit.go"
      to: "redis"
      via: "rate limit counter"
      pattern: "redis.*Incr"
---

<objective>
Implement security controls: upload rate limiting, presigned URL TTL enforcement, and verify orphan cleanup.

Purpose: Complete the security requirements for the image gallery. Add rate limiting for admin uploads to prevent abuse. Verify that presigned URLs have proper TTL. Ensure S3 deletion happens before DB deletion to prevent orphaned objects.

Output: New UploadRateLimit middleware, integration in main.go
</objective>

<execution_context>
@/home/munnotubbel/.claude/get-shit-done/workflows/execute-plan.md
@/home/munnotubbel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/munnotubbel/github/synesthesie-backend/.planning/PROJECT.md
@/home/munnotubbel/github/synesthesie-backend/.planning/ROADMAP.md
@/home/munnotubbel/github/synesthesie-backend/.planning/REQUIREMENTS.md
@/home/munnotubbel/github/synesthesie-backend/internal/middleware/rate_limiter.go
@/home/munnotubbel/github/synesthesie-backend/internal/middleware/admin_rate_limit.go
@/home/munnotubbel/github/synesthesie-backend/internal/services/media_service.go
@/home/munnotubbel/github/synesthesie-backend/cmd/api/main.go
@/home/munnotubbel/github/synesthesie-backend/internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create upload rate limiting middleware</name>
  <files>internal/middleware/upload_rate_limit.go</files>
  <action>
Create a new file internal/middleware/upload_rate_limit.go:

```go
package middleware

import (
    "context"
    "fmt"
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
    "github.com/redis/go-redis/v9"
    "github.com/synesthesie/backend/internal/config"
)

// UploadRateLimit creates a rate limiting middleware specifically for admin uploads
// Prevents abuse by limiting the number of uploads per admin within a time window
func UploadRateLimit(redisClient *redis.Client, cfg *config.Config) gin.HandlerFunc {
    return func(c *gin.Context) {
        ctx := context.Background()

        // Only apply to upload endpoints
        if c.Request.Method != "POST" {
            c.Next()
            return
        }

        // Check if this is an upload endpoint
        path := c.Request.URL.Path
        if !isUploadEndpoint(path) {
            c.Next()
            return
        }

        // Get admin ID from context (set by Auth middleware)
        userIDInterface, exists := c.Get("userID")
        if !exists {
            c.Next()
            return
        }

        adminID, ok := userIDInterface.(uuid.UUID)
        if !ok {
            c.Next()
            return
        }

        // Rate limit key: upload_limit:{admin_id}:{date}
        // Resets daily at midnight for predictable behavior
        today := time.Now().Format("2006-01-02")
        key := fmt.Sprintf("upload_limit:%s:%s", adminID.String(), today)

        // Check current count
        count, err := redisClient.Get(ctx, key).Int()
        if err == redis.Nil {
            // First upload today
            // Set with expiration until midnight
            now := time.Now()
            midnight := time.Date(now.Year(), now.Month(), now.Day()+1, 0, 0, 0, 0, now.Location())
            ttl := midnight.Sub(now)
            err = redisClient.Set(ctx, key, 1, ttl).Err()
            if err != nil {
                // Log error but don't block upload
                c.Next()
                return
            }
        } else if err != nil {
            // Redis error - don't block upload
            c.Next()
            return
        } else if count >= cfg.UploadMaxConcurrent*10 {
            // Rate limit: max 10x the concurrent limit per day
            // For default config (3 concurrent), this = 30 uploads/day
            ttl, _ := redisClient.TTL(ctx, key).Result()
            c.JSON(http.StatusTooManyRequests, gin.H{
                "error":               "upload_rate_limit_exceeded",
                "message":             "Too many uploads today. Please try again tomorrow.",
                "retry_after_hours":   int(ttl.Hours()),
                "uploads_today":       count,
                "max_uploads_per_day": cfg.UploadMaxConcurrent * 10,
            })
            c.Abort()
            return
        } else {
            // Increment counter
            redisClient.Incr(ctx, key)
        }

        c.Next()
    }
}

// isUploadEndpoint checks if the path is an upload endpoint
func isUploadEndpoint(path string) bool {
    // Check for image upload endpoints
    if path == "/api/v1/admin/images" || path == "/api/v1/admin/images/batch" {
        return true
    }
    // Check for asset upload endpoint (existing)
    if path == "/api/v1/admin/assets/upload" {
        return true
    }
    return false
}
```

Key design decisions:
- Daily reset at midnight (predictable for admins)
- Limit is 10x the concurrent limit (configurable via config)
- Uses Redis for distributed rate limiting
- Graceful degradation if Redis is unavailable
- Only applies to POST requests on upload endpoints
</action>
  <verify>
go build ./... 2>&1 | head -20
</verify>
  <done>
UploadRateLimit middleware exists with rate limiting logic
</done>
</task>

<task type="auto">
  <name>Task 2: Add upload rate config field</name>
  <files>internal/config/config.go</files>
  <action>
Verify that UploadMaxConcurrent is already present in config (added in Plan 02).

If not present, add to Config struct:
```go
UploadMaxConcurrent int    // Max concurrent uploads per admin (default: 3)
```

And in New() function:
```go
UploadMaxConcurrent: getEnvAsInt("UPLOAD_MAX_CONCURRENT", 3),
```

This field was added in Plan 02, so this task just verifies it exists.
</action>
  <verify>
grep "UploadMaxConcurrent" internal/config/config.go
</verify>
  <done>
UploadMaxConcurrent field exists in Config struct
</done>
</task>

<task type="auto">
  <name>Task 3: Integrate upload rate limiting in main.go</name>
  <files>cmd/api/main.go</files>
  <action>
Update cmd/api/main.go to add upload rate limiting middleware to admin upload routes.

There are two approaches:

**Option A: Group-level middleware (recommended)**
Create a rate-limited group for upload endpoints:

```go
// Admin upload routes with rate limiting (SEC-02)
uploadGroup := admin.Group("")
uploadGroup.Use(middleware.UploadRateLimit(redisClient, cfg))
{
    uploadGroup.POST("/images", mediaHandler.UploadImage)
    uploadGroup.POST("/images/batch", mediaHandler.UploadImages)
    uploadGroup.POST("/assets/upload", adminHandler.UploadAsset)
}
```

**Option B: Route-level middleware**
Add middleware to individual routes:

```go
admin.POST("/images", middleware.UploadRateLimit(redisClient, cfg), mediaHandler.UploadImage)
admin.POST("/images/batch", middleware.UploadRateLimit(redisClient, cfg), mediaHandler.UploadImages)
```

Use Option A for cleaner code. Move the upload routes into the uploadGroup and remove them from the main admin group.

Note: Non-upload routes (GET, PUT, DELETE) stay in the regular admin group without upload rate limiting.
</action>
  <verify>
grep "UploadRateLimit" cmd/api/main.go && go build ./...
</verify>
  <done>
main.go uses UploadRateLimit middleware on upload endpoints
</done>
</task>

<task type="auto">
  <name>Task 4: Verify security implementation</name>
  <files>N/A (verification only)</files>
  <action>
Verify all security requirements are implemented:

**SEC-01: Presigned URLs have 15-minute TTL**
- Check MediaService.GetPresignedImageURL uses cfg.PresignedURLTTLMinutes
- Check config default is 15 minutes

**SEC-02: Upload rate limiting**
- Check UploadRateLimit middleware exists
- Check it's applied to admin upload endpoints

**SEC-03: S3 bucket remains private**
- S3Service.UploadMedia uses ACL: s3types.ObjectCannedACLPrivate
- No public access configuration in code
- All access via presigned URLs

**SEC-04: Orphaned S3 objects avoided**
- Check MediaService.DeleteImage deletes S3 BEFORE DB
- Check error handling doesn't leave orphans

Run verification:
```bash
# Verify presigned URL TTL
grep -n "PresignedURLTTLMinutes" internal/config/config.go internal/services/media_service.go

# Verify S3 private ACL
grep -n "ObjectCannedACLPrivate" internal/services/s3_service.go

# Verify delete order (S3 before DB)
grep -A5 "Delete from S3 FIRST" internal/services/media_service.go

# Verify rate limiting
grep -n "UploadRateLimit" cmd/api/main.go internal/middleware/upload_rate_limit.go
```
</action>
  <verify>
grep -n "PresignedURLTTLMinutes\|ObjectCannedACLPrivate\|Delete from S3 FIRST\|UploadRateLimit" internal/services/*.go internal/config/*.go cmd/api/main.go internal/middleware/*.go 2>/dev/null | head -30
</verify>
  <done>
All security requirements verified in code
</done>
</task>

</tasks>

<verification>
1. Run `go build ./...` - must succeed
2. Verify UploadRateLimit middleware exists
3. Verify middleware is applied to upload endpoints in main.go
4. Verify presigned URL TTL uses config value (15 min default)
5. Verify S3 uploads use private ACL
6. Verify delete order: S3 first, then DB
7. Run docker build to verify container builds (optional, for production verification)
</verification>

<success_criteria>
- Upload rate limiting implemented (SEC-02)
- Rate limit: 30 uploads/day per admin (configurable)
- Presigned URLs use 15-minute TTL from config (SEC-01)
- S3 bucket stays private via ACL (SEC-03)
- Delete order: S3 before DB to prevent orphans (SEC-04)
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-image-gallery/01-06-SUMMARY.md`
</output>
