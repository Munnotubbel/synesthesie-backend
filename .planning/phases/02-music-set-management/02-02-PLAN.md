---
phase: 02-music-set-management
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - internal/services/music_service.go
  - internal/handlers/music_handler.go
  - cmd/api/main.go
autonomous: true
requirements:
  - MSC-ADM-01
  - MSC-ADM-04
must_haves:
  truths:
    - "Admin can create music sets via POST /admin/music-sets"
    - "Admin can list all music sets via GET /admin/music-sets"
    - "Admin can get music set details via GET /admin/music-sets/:id"
    - "Admin can delete music sets via DELETE /admin/music-sets/:id"
    - "Deleting music set removes all associated tracks and S3 objects"
  artifacts:
    - path: "internal/services/music_service.go"
      provides: "Music set CRUD operations"
      exports: ["CreateMusicSet", "GetAllMusicSets", "GetMusicSetByID", "DeleteMusicSet"]
      contains: "type MusicService struct"
    - path: "internal/handlers/music_handler.go"
      provides: "Admin music set HTTP handlers"
      exports: ["CreateMusicSet", "GetAllMusicSets", "GetMusicSetDetails", "DeleteMusicSet"]
    - path: "cmd/api/main.go"
      provides: "Route registration"
      contains: "/admin/music-sets"
  key_links:
    - from: "internal/handlers/music_handler.go"
      to: "internal/services/music_service.go"
      via: "dependency injection"
      pattern: "musicService.*MusicService"
    - from: "internal/services/music_service.go"
      to: "internal/services/s3_service.go"
      via: "DeleteMedia for track cleanup"
      pattern: "s3Service\\.DeleteMedia"
---

<objective>
Create MusicService and MusicHandler for music set CRUD operations.

Purpose: Enable admins to create, view, and delete music sets. This plan focuses on set-level operations. Track upload and management will be handled in Plan 03. Delete operations properly clean up S3 objects to avoid orphaned files (following SEC-04 pattern from Phase 1).

Output: New MusicService in internal/services/music_service.go, new MusicHandler in internal/handlers/music_handler.go, routes registered in main.go
</objective>

<execution_context>
@/home/munnotubbel/.claude/get-shit-done/workflows/execute-plan.md
@/home/munnotubbel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/munnotubbel/github/synesthesie-backend/.planning/PROJECT.md
@/home/munnotubbel/github/synesthesie-backend/.planning/ROADMAP.md
@/home/munnotubbel/github/synesthesie-backend/.planning/REQUIREMENTS.md
@/home/munnotubbel/github/synesthesie-backend/internal/models/music_set.go
@/home/munnotubbel/github/synesthesie-backend/internal/services/media_service.go
@/home/munnotubbel/github/synesthesie-backend/internal/handlers/media_handler.go
@/home/munnotubbel/github/synesthesie-backend/cmd/api/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MusicService for music set operations</name>
  <files>internal/services/music_service.go</files>
  <action>
Create a new file internal/services/music_service.go:

```go
package services

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/synesthesie/backend/internal/config"
	"github.com/synesthesie/backend/internal/models"
	"gorm.io/gorm"
)

type MusicService struct {
	db        *gorm.DB
	cfg       *config.Config
	s3Service *S3Service
}

func NewMusicService(db *gorm.DB, cfg *config.Config, s3Service *S3Service) *MusicService {
	return &MusicService{
		db:        db,
		cfg:       cfg,
		s3Service: s3Service,
	}
}

// CreateMusicSet creates a new music set (MSC-ADM-01)
func (s *MusicService) CreateMusicSet(title, description string) (*models.MusicSet, error) {
	if title == "" {
		return nil, fmt.Errorf("title is required")
	}

	musicSet := &models.MusicSet{
		Title:       title,
		Description: description,
		Visibility:  "private", // Default to private
	}

	if err := s.db.Create(musicSet).Error; err != nil {
		return nil, fmt.Errorf("failed to create music set: %w", err)
	}

	return musicSet, nil
}

// GetAllMusicSets returns all music sets for admin (with pagination)
func (s *MusicService) GetAllMusicSets(limit, offset int) ([]models.MusicSet, int64, error) {
	var sets []models.MusicSet
	var total int64

	if err := s.db.Model(&models.MusicSet{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}

	// Preload tracks with their assets, ordered by track_order
	if err := s.db.Preload("Tracks", func(db *gorm.DB) *gorm.DB {
		return db.Order("track_order ASC")
	}).Preload("Tracks.Asset").Order("created_at DESC").Limit(limit).Offset(offset).Find(&sets).Error; err != nil {
		return nil, 0, err
	}

	return sets, total, nil
}

// GetMusicSetByID returns a single music set with all tracks
func (s *MusicService) GetMusicSetByID(setID uuid.UUID) (*models.MusicSet, error) {
	var musicSet models.MusicSet
	if err := s.db.Preload("Tracks", func(db *gorm.DB) *gorm.DB {
		return db.Order("track_order ASC")
	}).Preload("Tracks.Asset").First(&musicSet, "id = ?", setID).Error; err != nil {
		return nil, err
	}
	return &musicSet, nil
}

// DeleteMusicSet deletes a music set and all its tracks (MSC-ADM-04)
// Follows SEC-04: Delete S3 objects first, then DB records
func (s *MusicService) DeleteMusicSet(ctx context.Context, setID uuid.UUID) error {
	var musicSet models.MusicSet
	if err := s.db.Preload("Tracks.Asset").First(&musicSet, "id = ?", setID).Error; err != nil {
		return fmt.Errorf("music set not found: %w", err)
	}

	// Delete all track S3 objects FIRST (SEC-04)
	for _, track := range musicSet.Tracks {
		if track.Asset != nil {
			if err := s.s3Service.DeleteMedia(ctx, s.cfg.MediaAudioBucket, track.Asset.Key); err != nil {
				// Log but continue - S3 might already be gone
			}
		}
	}

	// Delete DB records (MusicSet CASCADE deletes Tracks, then delete Assets manually)
	// First collect asset IDs to delete after
	assetIDs := make([]uuid.UUID, 0)
	for _, track := range musicSet.Tracks {
		if track.Asset != nil {
			assetIDs = append(assetIDs, track.Asset.ID)
		}
	}

	// Delete the music set (CASCADE will delete tracks)
	if err := s.db.Delete(&musicSet).Error; err != nil {
		return fmt.Errorf("failed to delete music set: %w", err)
	}

	// Delete asset records
	if len(assetIDs) > 0 {
		s.db.Delete(&models.Asset{}, "id IN ?", assetIDs)
	}

	return nil
}

// UpdateMusicSetVisibility changes the visibility of a music set (MSC-ADM-05)
func (s *MusicService) UpdateMusicSetVisibility(setID uuid.UUID, visibility string) error {
	if visibility != "private" && visibility != "public" {
		return fmt.Errorf("invalid visibility: must be 'private' or 'public'")
	}
	return s.db.Model(&models.MusicSet{}).Where("id = ?", setID).Update("visibility", visibility).Error
}

// UpdateMusicSetMetadata updates title and description
func (s *MusicService) UpdateMusicSetMetadata(setID uuid.UUID, title, description string) error {
	updates := map[string]interface{}{}
	if title != "" {
		updates["title"] = title
	}
	if description != "" {
		updates["description"] = description
	}
	if len(updates) == 0 {
		return nil
	}
	return s.db.Model(&models.MusicSet{}).Where("id = ?", setID).Updates(updates).Error
}
</action>
  <verify>
go build ./... 2>&1 | head -30
</verify>
  <done>
MusicService exists with CreateMusicSet, GetAllMusicSets, GetMusicSetByID, DeleteMusicSet, UpdateMusicSetVisibility, UpdateMusicSetMetadata methods
</done>
</task>

<task type="auto">
  <name>Task 2: Create MusicHandler for admin music set endpoints</name>
  <files>internal/handlers/music_handler.go</files>
  <action>
Create a new file internal/handlers/music_handler.go:

```go
package handlers

import (
	"net/http"
	"strconv"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/synesthesie/backend/internal/services"
)

type MusicHandler struct {
	musicService *services.MusicService
}

func NewMusicHandler(musicService *services.MusicService) *MusicHandler {
	return &MusicHandler{
		musicService: musicService,
	}
}

// CreateMusicSet handles music set creation (MSC-ADM-01)
// POST /admin/music-sets
// Body: {"title": "...", "description": "..."}
func (h *MusicHandler) CreateMusicSet(c *gin.Context) {
	var req struct {
		Title       string `json:"title" binding:"required"`
		Description string `json:"description"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "title is required"})
		return
	}

	musicSet, err := h.musicService.CreateMusicSet(req.Title, req.Description)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"id":          musicSet.ID,
		"title":       musicSet.Title,
		"description": musicSet.Description,
		"visibility":  musicSet.Visibility,
		"created_at":  musicSet.CreatedAt,
	})
}

// GetAllMusicSets lists all music sets for admin
// GET /admin/music-sets?page=1&limit=20
func (h *MusicHandler) GetAllMusicSets(c *gin.Context) {
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
	if limit > 100 {
		limit = 100
	}
	offset := (page - 1) * limit

	sets, total, err := h.musicService.GetAllMusicSets(limit, offset)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to retrieve music sets"})
		return
	}

	// Build response with track counts
	setList := make([]gin.H, len(sets))
	for i, set := range sets {
		trackCount := len(set.Tracks)
		setList[i] = gin.H{
			"id":          set.ID,
			"title":       set.Title,
			"description": set.Description,
			"visibility":  set.Visibility,
			"track_count": trackCount,
			"created_at":  set.CreatedAt,
			"updated_at":  set.UpdatedAt,
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"music_sets": setList,
		"pagination": gin.H{
			"page":  page,
			"limit": limit,
			"total": total,
		},
	})
}

// GetMusicSetDetails gets single music set details with tracks
// GET /admin/music-sets/:id
func (h *MusicHandler) GetMusicSetDetails(c *gin.Context) {
	setIDStr := c.Param("id")
	setID, err := uuid.Parse(setIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid music set ID"})
		return
	}

	musicSet, err := h.musicService.GetMusicSetByID(setID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "music set not found"})
		return
	}

	// Build tracks response
	tracks := make([]gin.H, len(musicSet.Tracks))
	for i, track := range musicSet.Tracks {
		trackData := gin.H{
			"id":          track.ID,
			"title":       track.Title,
			"artist":      track.Artist,
			"track_order": track.TrackOrder,
			"duration":    track.Duration,
			"created_at":  track.CreatedAt,
		}
		if track.Asset != nil {
			trackData["filename"] = track.Asset.Filename
			trackData["mime_type"] = track.Asset.MimeType
			trackData["size_bytes"] = track.Asset.SizeBytes
		}
		tracks[i] = trackData
	}

	c.JSON(http.StatusOK, gin.H{
		"id":          musicSet.ID,
		"title":       musicSet.Title,
		"description": musicSet.Description,
		"visibility":  musicSet.Visibility,
		"tracks":      tracks,
		"created_at":  musicSet.CreatedAt,
		"updated_at":  musicSet.UpdatedAt,
	})
}

// DeleteMusicSet handles music set deletion (MSC-ADM-04)
// DELETE /admin/music-sets/:id
func (h *MusicHandler) DeleteMusicSet(c *gin.Context) {
	setIDStr := c.Param("id")
	setID, err := uuid.Parse(setIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid music set ID"})
		return
	}

	if err := h.musicService.DeleteMusicSet(c.Request.Context(), setID); err != nil {
		if strings.Contains(err.Error(), "not found") {
			c.JSON(http.StatusNotFound, gin.H{"error": "music set not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete music set"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "music set deleted successfully",
		"id":      setID,
	})
}
</action>
  <verify>
go build ./... 2>&1 | head -30
</verify>
  <done>
MusicHandler exists with CreateMusicSet, GetAllMusicSets, GetMusicSetDetails, DeleteMusicSet methods
</done>
</task>

<task type="auto">
  <name>Task 3: Wire MusicService and MusicHandler in main.go</name>
  <files>cmd/api/main.go</files>
  <action>
Update cmd/api/main.go to initialize MusicService and MusicHandler, then register routes:

1. After creating mediaService (around line 65), create MusicService:
```go
musicService := services.NewMusicService(db, cfg, s3Service)
```

2. After creating other handlers (around line 194), create MusicHandler:
```go
musicHandler := handlers.NewMusicHandler(musicService)
```

3. In the admin routes group (after image gallery routes, around line 341), add music set routes:
```go
// Music set management
admin.GET("/music-sets", musicHandler.GetAllMusicSets)
admin.GET("/music-sets/:id", musicHandler.GetMusicSetDetails)
admin.POST("/music-sets", musicHandler.CreateMusicSet)
admin.DELETE("/music-sets/:id", musicHandler.DeleteMusicSet)
```

Note: Use the existing mediaService variable name (already exists from Phase 1). The new service is named musicService (lowercase m) to distinguish from MediaService which handles images.
</action>
  <verify>
grep -n "musicService\|musicHandler\|music-sets" cmd/api/main.go && go build ./...
</verify>
  <done>
main.go creates MusicService, MusicHandler, and registers /admin/music-sets routes
</done>
</task>

</tasks>

<verification>
1. Run `go build ./...` - must succeed
2. Verify MusicService has CreateMusicSet, GetAllMusicSets, GetMusicSetByID, DeleteMusicSet methods
3. Verify MusicHandler has corresponding HTTP handler methods
4. Verify main.go creates MusicService and MusicHandler
5. Verify routes registered: GET/POST /admin/music-sets, GET/DELETE /admin/music-sets/:id
</verification>

<success_criteria>
- Admin can create music sets with title and description (MSC-ADM-01)
- Admin can list all music sets with track counts
- Admin can view music set details with all tracks
- Admin can delete music sets with proper S3 cleanup (MSC-ADM-04)
- Delete follows SEC-04 pattern: S3 first, then DB
- All routes registered with auth middleware
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-music-set-management/02-02-SUMMARY.md`
</output>
