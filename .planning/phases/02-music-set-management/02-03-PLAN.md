---
phase: 02-music-set-management
plan: 03
type: execute
wave: 3
depends_on:
  - 02-02
files_modified:
  - internal/config/config.go
  - internal/services/music_service.go
  - internal/handlers/music_handler.go
  - cmd/api/main.go
autonomous: true
requirements:
  - MSC-ADM-02
  - MSC-ADM-03
  - MSC-ADM-07
must_haves:
  truths:
    - "Admin can upload audio tracks to music sets via POST /admin/music-sets/:id/tracks"
    - "Audio uploads support large files up to 4GB (FLAC)"
    - "Admin can remove tracks from sets via DELETE /admin/music-sets/:id/tracks/:trackId"
    - "MIME type validation ensures only FLAC/MP3 files are accepted"
    - "Track removal also deletes S3 object and Asset record"
  artifacts:
    - path: "internal/config/config.go"
      provides: "Audio upload size limit configuration"
      contains: "UploadMaxAudioSize"
    - path: "internal/services/music_service.go"
      provides: "Track upload and deletion"
      exports: ["UploadTrack", "DeleteTrack"]
      contains: "DetectContentType"
    - path: "internal/handlers/music_handler.go"
      provides: "Track upload HTTP handlers"
      exports: ["UploadTrack", "DeleteTrack"]
    - path: "cmd/api/main.go"
      provides: "Route registration with upload rate limiting"
      contains: "music-sets/:id/tracks"
  key_links:
    - from: "internal/handlers/music_handler.go"
      to: "internal/services/music_service.go"
      via: "method calls"
      pattern: "musicService\\.(Upload|Delete)"
    - from: "internal/services/music_service.go"
      to: "internal/services/s3_service.go"
      via: "UploadMedia to audio bucket"
      pattern: "MediaAudioBucket"
---

<objective>
Add track upload and management functionality to MusicService and MusicHandler.

Purpose: Enable admins to upload audio tracks to music sets and remove tracks. Audio uploads support large files (up to 4GB FLAC). MIME type validation ensures only valid audio formats are accepted (FLAC/MP3). Track deletion properly cleans up S3 objects following SEC-04 pattern.

Output: Extended Config with audio size limits, extended MusicService with UploadTrack/DeleteTrack, extended MusicHandler with upload/delete endpoints
</objective>

<execution_context>
@/home/munnotubbel/.claude/get-shit-done/workflows/execute-plan.md
@/home/munnotubbel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/munnotubbel/github/synesthesie-backend/.planning/PROJECT.md
@/home/munnotubbel/github/synesthesie-backend/.planning/ROADMAP.md
@/home/munnotubbel/github/synesthesie-backend/.planning/REQUIREMENTS.md
@/home/munnotubbel/github/synesthesie-backend/internal/services/music_service.go
@/home/munnotubbel/github/synesthesie-backend/internal/handlers/music_handler.go
@/home/munnotubbel/github/synesthesie-backend/internal/config/config.go
@/home/munnotubbel/github/synesthesie-backend/cmd/api/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add audio upload configuration</name>
  <files>internal/config/config.go</files>
  <action>
Add audio upload configuration fields to the Config struct in internal/config/config.go:

1. Add to Config struct (after PresignedURLTTLMinutes, around line 140):
```go
// Audio upload limits
UploadMaxAudioSize int64 // Max audio size in bytes (default: 4GB)
```

2. Add defaults to New() function (after PresignedURLTTLMinutes line, around line 274):
```go
// Audio upload limits
UploadMaxAudioSize: getEnvAsInt64("UPLOAD_MAX_AUDIO_SIZE", 4*1024*1024*1024), // 4GB
```

This supports MSC-ADM-07 (4GB FLAC support) and follows the existing pattern for UploadMaxImageSize.
</action>
  <verify>
go build ./... 2>&1 | head -20
</verify>
  <done>
Config struct has UploadMaxAudioSize field with 4GB default
</done>
</task>

<task type="auto">
  <name>Task 2: Add UploadTrack and DeleteTrack methods to MusicService</name>
  <files>internal/services/music_service.go</files>
  <action>
Add the following methods to MusicService in internal/services/music_service.go:

```go
import (
	// Add these imports if not present:
	"bytes"
	"net/http"
	"path/filepath"
	"strings"
)

// UploadTrack uploads an audio track to a music set (MSC-ADM-02, MSC-ADM-07)
// Supports large files up to 4GB, validates MIME type (FLAC/MP3 only)
func (s *MusicService) UploadTrack(ctx context.Context, setID uuid.UUID, filename string, data []byte, title, artist string, trackOrder int) (*models.MusicTrack, error) {
	// Verify music set exists
	var musicSet models.MusicSet
	if err := s.db.First(&musicSet, "id = ?", setID).Error; err != nil {
		return nil, fmt.Errorf("music set not found: %w", err)
	}

	// Validate MIME type using content detection (MSC-ADM-07)
	mimeType := http.DetectContentType(data)
	validAudioTypes := map[string]bool{
		"audio/flac":    true,
		"audio/x-flac":  true,
		"audio/mpeg":    true, // MP3
		"audio/mp3":     true,
		"audio/wav":     true,
		"audio/x-wav":   true,
	}
	if !validAudioTypes[mimeType] {
		return nil, fmt.Errorf("invalid audio type: %s (only FLAC/MP3/WAV allowed)", mimeType)
	}

	// Validate file extension
	ext := strings.ToLower(filepath.Ext(filename))
	allowedExts := map[string]bool{".flac": true, ".mp3": true, ".wav": true}
	if !allowedExts[ext] {
		return nil, fmt.Errorf("unsupported audio extension: %s", ext)
	}

	// Validate size (4GB max for MSC-ADM-07)
	if int64(len(data)) > s.cfg.UploadMaxAudioSize {
		return nil, fmt.Errorf("audio too large: %d bytes (max: %d)", len(data), s.cfg.UploadMaxAudioSize)
	}

	// Auto-assign track order if not specified
	if trackOrder <= 0 {
		var maxOrder int
		s.db.Model(&models.MusicTrack{}).Where("music_set_id = ?", setID).Select("COALESCE(MAX(track_order), 0)").Scan(&maxOrder)
		trackOrder = maxOrder + 1
	}

	// Generate S3 key
	key := fmt.Sprintf("tracks/%s/%s%s", setID.String(), uuid.New().String(), ext)

	// Upload to S3 (mediaClient -> MediaAudioBucket)
	if err := s.s3Service.UploadMedia(ctx, s.cfg.MediaAudioBucket, key, bytes.NewReader(data), mimeType); err != nil {
		return nil, fmt.Errorf("failed to upload to S3: %w", err)
	}

	// Create Asset record
	asset := &models.Asset{
		Key:        key,
		Filename:   filename,
		MimeType:   mimeType,
		SizeBytes:  int64(len(data)),
		Visibility: models.AssetVisibilityPrivate, // Audio always private - use MusicSet.Visibility
	}
	if err := s.db.Create(asset).Error; err != nil {
		// Attempt S3 cleanup on DB failure (SEC-04)
		_ = s.s3Service.DeleteMedia(ctx, s.cfg.MediaAudioBucket, key)
		return nil, fmt.Errorf("failed to create asset record: %w", err)
	}

	// Create MusicTrack record
	track := &models.MusicTrack{
		MusicSetID: setID,
		AssetID:    asset.ID,
		Title:      title,
		Artist:     artist,
		TrackOrder: trackOrder,
	}
	if err := s.db.Create(track).Error; err != nil {
		// Cleanup: delete asset and S3 object
		s.db.Delete(asset)
		_ = s.s3Service.DeleteMedia(ctx, s.cfg.MediaAudioBucket, key)
		return nil, fmt.Errorf("failed to create track record: %w", err)
	}

	// Load asset relation
	track.Asset = asset

	return track, nil
}

// DeleteTrack removes a track from a music set (MSC-ADM-03)
// Follows SEC-04: Delete S3 object first, then DB records
func (s *MusicService) DeleteTrack(ctx context.Context, setID, trackID uuid.UUID) error {
	var track models.MusicTrack
	if err := s.db.Preload("Asset").First(&track, "id = ? AND music_set_id = ?", trackID, setID).Error; err != nil {
		return fmt.Errorf("track not found: %w", err)
	}

	// Delete from S3 FIRST (SEC-04)
	if track.Asset != nil {
		if err := s.s3Service.DeleteMedia(ctx, s.cfg.MediaAudioBucket, track.Asset.Key); err != nil {
			// Log but continue - S3 might already be gone
		}
	}

	// Delete DB records (Track first, then Asset)
	if err := s.db.Delete(&track).Error; err != nil {
		return fmt.Errorf("failed to delete track record: %w", err)
	}
	if track.Asset != nil {
		if err := s.db.Delete(track.Asset).Error; err != nil {
			return fmt.Errorf("failed to delete asset record: %w", err)
		}
	}

	return nil
}

// GetTrackByID returns a single track by ID (for metadata editing)
func (s *MusicService) GetTrackByID(trackID uuid.UUID) (*models.MusicTrack, error) {
	var track models.MusicTrack
	if err := s.db.Preload("Asset").First(&track, "id = ?", trackID).Error; err != nil {
		return nil, err
	}
	return &track, nil
}
```

Add the required imports at the top of the file if not already present.
</action>
  <verify>
go build ./... 2>&1 | head -30
</verify>
  <done>
MusicService has UploadTrack, DeleteTrack, GetTrackByID methods with MIME validation
</done>
</task>

<task type="auto">
  <name>Task 3: Add track upload and delete handlers to MusicHandler</name>
  <files>internal/handlers/music_handler.go</files>
  <action>
Add the following methods to MusicHandler in internal/handlers/music_handler.go:

```go
import (
	// Add these imports if not present:
	"io"
	"strconv"
)

// UploadTrack handles audio track upload to a music set (MSC-ADM-02, MSC-ADM-07)
// POST /admin/music-sets/:id/tracks
// Multipart form: file (required), title (optional), artist (optional), track_order (optional)
func (h *MusicHandler) UploadTrack(c *gin.Context) {
	setIDStr := c.Param("id")
	setID, err := uuid.Parse(setIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid music set ID"})
		return
	}

	// Get file from form
	file, header, err := c.Request.FormFile("file")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "file is required"})
		return
	}
	defer file.Close()

	// Read file content for MIME detection and upload
	data, err := io.ReadAll(file)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "failed to read file"})
		return
	}

	// Get optional metadata
	title := c.PostForm("title")
	artist := c.PostForm("artist")
	trackOrder, _ := strconv.Atoi(c.PostForm("track_order"))

	// Use filename as title if not provided
	if title == "" {
		title = strings.TrimSuffix(header.Filename, filepath.Ext(header.Filename))
	}

	// Upload via MusicService (handles MIME validation internally)
	track, err := h.musicService.UploadTrack(c.Request.Context(), setID, header.Filename, data, title, artist, trackOrder)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"id":          track.ID,
		"music_set_id": track.MusicSetID,
		"title":       track.Title,
		"artist":      track.Artist,
		"track_order": track.TrackOrder,
		"filename":    track.Asset.Filename,
		"mime_type":   track.Asset.MimeType,
		"size_bytes":  track.Asset.SizeBytes,
		"created_at":  track.CreatedAt,
	})
}

// DeleteTrack handles track removal from a music set (MSC-ADM-03)
// DELETE /admin/music-sets/:id/tracks/:trackId
func (h *MusicHandler) DeleteTrack(c *gin.Context) {
	setIDStr := c.Param("id")
	setID, err := uuid.Parse(setIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid music set ID"})
		return
	}

	trackIDStr := c.Param("trackId")
	trackID, err := uuid.Parse(trackIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid track ID"})
		return
	}

	if err := h.musicService.DeleteTrack(c.Request.Context(), setID, trackID); err != nil {
		if strings.Contains(err.Error(), "not found") {
			c.JSON(http.StatusNotFound, gin.H{"error": "track not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete track"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":  "track deleted successfully",
		"id":       trackID,
		"set_id":   setID,
	})
}
```

Add required imports at the top of the file:
- "io"
- "path/filepath"
- "strconv"
</action>
  <verify>
go build ./... 2>&1 | head -30
</verify>
  <done>
MusicHandler has UploadTrack and DeleteTrack methods
</done>
</task>

<task type="auto">
  <name>Task 4: Register track routes in main.go</name>
  <files>cmd/api/main.go</files>
  <action>
Add the new track routes to the admin routes group in cmd/api/main.go.

Find the music set routes section (added in Plan 02) and extend it with track routes.
The track upload should use the existing uploadGroup with rate limiting:

```go
// Music set management (read operations)
admin.GET("/music-sets", musicHandler.GetAllMusicSets)
admin.GET("/music-sets/:id", musicHandler.GetMusicSetDetails)
admin.POST("/music-sets", musicHandler.CreateMusicSet)
admin.DELETE("/music-sets/:id", musicHandler.DeleteMusicSet)
admin.DELETE("/music-sets/:id/tracks/:trackId", musicHandler.DeleteTrack)

// Track upload with rate limiting (add to uploadGroup)
uploadGroup.POST("/music-sets/:id/tracks", musicHandler.UploadTrack)
```

The uploadGroup already exists (from Phase 1) with UploadRateLimit middleware applied.
</action>
  <verify>
grep -E "music-sets.*tracks|musicHandler" cmd/api/main.go && go build ./...
</verify>
  <done>
main.go has track upload and delete routes with proper rate limiting
</done>
</task>

</tasks>

<verification>
1. Run `go build ./...` - must succeed
2. Verify Config has UploadMaxAudioSize with 4GB default
3. Verify MusicService.UploadTrack validates MIME type (FLAC/MP3/WAV only)
4. Verify MusicService.UploadTrack validates size (4GB max)
5. Verify MusicHandler has UploadTrack and DeleteTrack
6. Verify track upload route uses uploadGroup (rate limited)
7. Verify track delete route is registered
</verification>

<success_criteria>
- Admin can upload audio tracks to music sets (MSC-ADM-02)
- Audio uploads support 4GB files (MSC-ADM-07)
- MIME type validation allows only FLAC/MP3/WAV (MSC-ADM-07)
- Admin can remove tracks from sets (MSC-ADM-03)
- Track deletion removes S3 object and DB records (SEC-04)
- Upload rate limiting applied (SEC-02)
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-music-set-management/02-03-SUMMARY.md`
</output>
