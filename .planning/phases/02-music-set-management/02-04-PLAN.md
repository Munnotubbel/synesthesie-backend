---
phase: 02-music-set-management
plan: 04
type: execute
wave: 4
depends_on:
  - 02-03
files_modified:
  - internal/services/music_service.go
  - internal/handlers/music_handler.go
  - cmd/api/main.go
autonomous: true
requirements:
  - MSC-ADM-05
  - MSC-ADM-06
must_haves:
  truths:
    - "Admin can change music set visibility via PUT /admin/music-sets/:id/visibility"
    - "Admin can edit music set metadata via PUT /admin/music-sets/:id"
    - "Admin can edit track metadata (title, artist) via PUT /admin/music-sets/:id/tracks/:trackId"
    - "Admin can reorder tracks via PUT /admin/music-sets/:id/tracks/reorder"
  artifacts:
    - path: "internal/services/music_service.go"
      provides: "Visibility and metadata update methods"
      exports: ["UpdateMusicSetVisibility", "UpdateMusicSetMetadata", "UpdateTrackMetadata", "ReorderTracks"]
    - path: "internal/handlers/music_handler.go"
      provides: "Visibility and metadata HTTP handlers"
      exports: ["UpdateMusicSetVisibility", "UpdateMusicSetMetadata", "UpdateTrackMetadata", "ReorderTracks"]
    - path: "cmd/api/main.go"
      provides: "Route registration"
      contains: "visibility"
  key_links:
    - from: "internal/handlers/music_handler.go"
      to: "internal/services/music_service.go"
      via: "method calls"
      pattern: "musicService\\.Update"
---

<objective>
Add visibility and metadata management endpoints for music sets and tracks.

Purpose: Complete the admin music management functionality. Admins need to be able to change music set visibility (private/public) and edit metadata for both sets and individual tracks (title, artist). Also provide track reordering capability for proper playlist management.

Output: Extended MusicService with UpdateTrackMetadata and ReorderTracks, extended MusicHandler with visibility/metadata endpoints
</objective>

<execution_context>
@/home/munnotubbel/.claude/get-shit-done/workflows/execute-plan.md
@/home/munnotubbel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/munnotubbel/github/synesthesie-backend/.planning/PROJECT.md
@/home/munnotubbel/github/synesthesie-backend/.planning/ROADMAP.md
@/home/munnotubbel/github/synesthesie-backend/.planning/REQUIREMENTS.md
@/home/munnotubbel/github/synesthesie-backend/internal/services/music_service.go
@/home/munnotubbel/github/synesthesie-backend/internal/handlers/music_handler.go
@/home/munnotubbel/github/synesthesie-backend/cmd/api/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add UpdateTrackMetadata and ReorderTracks to MusicService</name>
  <files>internal/services/music_service.go</files>
  <action>
Add the following methods to MusicService in internal/services/music_service.go:

```go
// UpdateTrackMetadata updates title and artist for a track (MSC-ADM-06)
func (s *MusicService) UpdateTrackMetadata(trackID uuid.UUID, title, artist string) error {
	updates := map[string]interface{}{}
	if title != "" {
		updates["title"] = title
	}
	if artist != "" {
		updates["artist"] = artist
	}
	if len(updates) == 0 {
		return nil
	}
	return s.db.Model(&models.MusicTrack{}).Where("id = ?", trackID).Updates(updates).Error
}

// ReorderTracks updates the track_order for multiple tracks in a set
// Expects a map of trackID -> new order
func (s *MusicService) ReorderTracks(setID uuid.UUID, trackOrders map[uuid.UUID]int) error {
	return s.db.Transaction(func(tx *gorm.DB) error {
		for trackID, order := range trackOrders {
			result := tx.Model(&models.MusicTrack{}).
				Where("id = ? AND music_set_id = ?", trackID, setID).
				Update("track_order", order)
			if result.Error != nil {
				return result.Error
			}
			if result.RowsAffected == 0 {
				return fmt.Errorf("track %s not found in set %s", trackID, setID)
			}
		}
		return nil
	})
}
```

Note: UpdateMusicSetVisibility and UpdateMusicSetMetadata were already added in Plan 02.
</action>
  <verify>
go build ./... 2>&1 | head -20
</verify>
  <done>
MusicService has UpdateTrackMetadata and ReorderTracks methods
</done>
</task>

<task type="auto">
  <name>Task 2: Add visibility and metadata handlers to MusicHandler</name>
  <files>internal/handlers/music_handler.go</files>
  <action>
Add the following methods to MusicHandler in internal/handlers/music_handler.go:

```go
// UpdateMusicSetVisibility changes visibility between private/public (MSC-ADM-05)
// PUT /admin/music-sets/:id/visibility
// Body: {"visibility": "public"} or {"visibility": "private"}
func (h *MusicHandler) UpdateMusicSetVisibility(c *gin.Context) {
	setIDStr := c.Param("id")
	setID, err := uuid.Parse(setIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid music set ID"})
		return
	}

	var req struct {
		Visibility string `json:"visibility" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "visibility is required"})
		return
	}

	if req.Visibility != "private" && req.Visibility != "public" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "visibility must be 'private' or 'public'"})
		return
	}

	if err := h.musicService.UpdateMusicSetVisibility(setID, req.Visibility); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update visibility"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":    "visibility updated successfully",
		"id":         setID,
		"visibility": req.Visibility,
	})
}

// UpdateMusicSetMetadata updates title and description for a set
// PUT /admin/music-sets/:id
// Body: {"title": "...", "description": "..."} (both optional)
func (h *MusicHandler) UpdateMusicSetMetadata(c *gin.Context) {
	setIDStr := c.Param("id")
	setID, err := uuid.Parse(setIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid music set ID"})
		return
	}

	var req struct {
		Title       *string `json:"title"`
		Description *string `json:"description"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var title, description string
	if req.Title != nil {
		title = *req.Title
	}
	if req.Description != nil {
		description = *req.Description
	}

	if err := h.musicService.UpdateMusicSetMetadata(setID, title, description); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update metadata"})
		return
	}

	// Return updated set
	musicSet, err := h.musicService.GetMusicSetByID(setID)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"message": "metadata updated successfully",
			"id":      setID,
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":     "metadata updated successfully",
		"id":          musicSet.ID,
		"title":       musicSet.Title,
		"description": musicSet.Description,
	})
}

// UpdateTrackMetadata updates title and artist for a track (MSC-ADM-06)
// PUT /admin/music-sets/:id/tracks/:trackId
// Body: {"title": "...", "artist": "..."} (both optional)
func (h *MusicHandler) UpdateTrackMetadata(c *gin.Context) {
	setIDStr := c.Param("id")
	setID, err := uuid.Parse(setIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid music set ID"})
		return
	}

	trackIDStr := c.Param("trackId")
	trackID, err := uuid.Parse(trackIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid track ID"})
		return
	}

	var req struct {
		Title  *string `json:"title"`
		Artist *string `json:"artist"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var title, artist string
	if req.Title != nil {
		title = *req.Title
	}
	if req.Artist != nil {
		artist = *req.Artist
	}

	if err := h.musicService.UpdateTrackMetadata(trackID, title, artist); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update track metadata"})
		return
	}

	// Return updated track
	track, err := h.musicService.GetTrackByID(trackID)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"message": "track metadata updated successfully",
			"id":      trackID,
			"set_id":  setID,
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "track metadata updated successfully",
		"id":      track.ID,
		"set_id":  setID,
		"title":   track.Title,
		"artist":  track.Artist,
	})
}

// ReorderTracks updates track order within a set
// PUT /admin/music-sets/:id/tracks/reorder
// Body: {"orders": {"track-uuid-1": 1, "track-uuid-2": 2, ...}}
func (h *MusicHandler) ReorderTracks(c *gin.Context) {
	setIDStr := c.Param("id")
	setID, err := uuid.Parse(setIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid music set ID"})
		return
	}

	var req struct {
		Orders map[string]int `json:"orders" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "orders map is required"})
		return
	}

	// Convert string keys to UUIDs
	trackOrders := make(map[uuid.UUID]int)
	for trackIDStr, order := range req.Orders {
		trackID, err := uuid.Parse(trackIDStr)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("invalid track ID: %s", trackIDStr)})
			return
		}
		trackOrders[trackID] = order
	}

	if err := h.musicService.ReorderTracks(setID, trackOrders); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "tracks reordered successfully",
		"set_id":  setID,
	})
}
```

Add "fmt" import if not already present.
</action>
  <verify>
go build ./... 2>&1 | head -30
</verify>
  <done>
MusicHandler has UpdateMusicSetVisibility, UpdateMusicSetMetadata, UpdateTrackMetadata, ReorderTracks methods
</done>
</task>

<task type="auto">
  <name>Task 3: Register visibility and metadata routes in main.go</name>
  <files>cmd/api/main.go</files>
  <action>
Add the new routes to the admin routes group in cmd/api/main.go.

Find the music set routes section and add the visibility and metadata routes.
IMPORTANT: Register specific routes BEFORE generic :id route to avoid conflicts:

```go
// Music set management
admin.GET("/music-sets", musicHandler.GetAllMusicSets)
admin.POST("/music-sets", musicHandler.CreateMusicSet)
admin.GET("/music-sets/:id", musicHandler.GetMusicSetDetails)
admin.PUT("/music-sets/:id/visibility", musicHandler.UpdateMusicSetVisibility)  // Before :id route
admin.PUT("/music-sets/:id/tracks/reorder", musicHandler.ReorderTracks)          // Before :id route
admin.PUT("/music-sets/:id", musicHandler.UpdateMusicSetMetadata)
admin.DELETE("/music-sets/:id", musicHandler.DeleteMusicSet)
admin.DELETE("/music-sets/:id/tracks/:trackId", musicHandler.DeleteTrack)
admin.PUT("/music-sets/:id/tracks/:trackId", musicHandler.UpdateTrackMetadata)
```

Note: The track upload route is in uploadGroup (rate-limited) from Plan 03.
</action>
  <verify>
grep -E "music-sets.*visibility|music-sets.*reorder|UpdateMusicSetMetadata|UpdateTrackMetadata" cmd/api/main.go && go build ./...
</verify>
  <done>
main.go has visibility, metadata, and reorder routes for music sets and tracks
</done>
</task>

</tasks>

<verification>
1. Run `go build ./...` - must succeed
2. Verify MusicService has UpdateTrackMetadata and ReorderTracks
3. Verify MusicHandler has UpdateMusicSetVisibility, UpdateMusicSetMetadata, UpdateTrackMetadata, ReorderTracks
4. Verify routes registered: PUT /admin/music-sets/:id/visibility, PUT /admin/music-sets/:id, PUT /admin/music-sets/:id/tracks/:trackId, PUT /admin/music-sets/:id/tracks/reorder
5. Verify visibility route is registered before generic :id route
</verification>

<success_criteria>
- Admin can change music set visibility to private/public (MSC-ADM-05)
- Admin can edit music set title and description
- Admin can edit track title and artist (MSC-ADM-06)
- Admin can reorder tracks within a set
- All routes registered with proper ordering
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-music-set-management/02-04-SUMMARY.md`
</output>
